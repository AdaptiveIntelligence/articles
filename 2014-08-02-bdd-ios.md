---
layout: post
title:  "BDD"
category: "1"
date: "2013-07-11 08:00:00"
author: "<a href=\"https://paweldudek.github.io\">Pawel Dudek</a>"
tags: article
---

We all know that writing tests is a great thing.[link to Luis Solano article]. There've been numerous articles written on why TDD is a great way for us programmers to write apps. But there's on

By writing a test first you're not only the creator of an interface. You are also becoming the *first consumer* of it. And by doing that you get this unique chance to feel whether the interface is easily understandable and usable. 

But how does BDD differ from TDD? My personal favorite definiton comes from [article](http://blog.mattwynne.net/2012/11/20/tdd-vs-bdd/) by Matt Wynne. Here's the most important part of it:

> BDD builds upon TDD by formalising the good habits of the best TDD practitioners. (â€¦) Specifically, I think those good habits are:
>
> * Working outside-in, starting from a business or organisational goal
> * Using examples to clarify requirements
> * Developing and using a ubiquitous language

Let's briefly discuss these three points. 	
if it is hard to <missing stuff> clarify requirements


## BDD Frameworks

As an iOS developer you can choose from a variety of BDD frameworks:

* [Specta](https://github.com/specta/specta)
* [Kiwi](https://github.com/kiwi-bdd/Kiwi)
* [Cedar](https://github.com/pivotal/cedar)

BDD frameworks inherit their syntax from RSpec[^1], a Ruby BDD framework. Here's a simple example of how BDD syntaxt looks like:

	SpecBegin(Car)
		describe(@"Car", ^{
		
			__block Car *car;
		
			// Will be run before each enclosed it
			beforeEach(^{
				car = [Car new];
			});
			
			// Will be run after each enclosed it
			afterEach(^{
				car = nil;
			});
		
			// An actual test
			it(@"should be red", ^{
				expect(car).to.beRed();
			});
			
			describe(@"when it is started", ^{
			
				beforeEach(^{
					[car start];
				});
			
				it(@"should have engine running", ^{
					expect(car.engine).to.beRunning();
				});
			
			});
		});
	SpecEnd
	
`SpecBegin` declared a test class named `CarSpec`. `SpecEnd` closes that class declaration. `describe` block declares a group of examples that are tied to the subject (first parameter) of the block. `it` is a single example (test). Subjects of `describe` and `it` blocks are later used to construct names of examples, for instance `Car when it is started should have engine running`. 
	
If you wish to learn more about RSpec syntax you can check out [Specta guide for writing specs](https://github.com/specta/specta#writing-specs).

When it comes to syntax Specta, Kiwi and Cedar are nearly the same. Main difference between them lies in their configurability and bundled components. 

Cedar comes bundled with [matchers](https://github.com/pivotal/cedar/wiki/Writing-specs#matchers) and [doubles](https://github.com/pivotal/cedar/wiki/Writing-specs#doubles). Thought not exactly true for the sake of this article let's consider doubles as mocks (you can read what doubles really are [here](http://martinfowler.com/articles/mocksArentStubs.html)). Apart from these helpers Cedar has additional configuration feature: focusing tests. Focusing tests means that you are asking Cedar to run only that particlar test or a group of tests. Focusing can be achieved by adding an `f` before `it` or `describe` block. There's an opposite configuration capability: you can `x`' test to turn it off. Similar thing can be achieved by running single tests with XCTest, however the approach Cedar provides is much simpler and faster to configure. Cedar doesn't really integrate with XCTest as it only uses Xcode's `RunUnitTests` tool rather than actually using XCTest classess.

Kiwi also comes bundled with [matchers](https://github.com/kiwi-bdd/Kiwi/wiki/Expectations) as well as [stubs and mocks](https://github.com/kiwi-bdd/Kiwi/wiki/Mocks-and-Stubs). Unlike Cedar Kiwi is tightly integrated with XCTest, however it lacks configuration capabilities available in Cedar. 

Specta offers a different approach when it comes to testing tools as it lacks any matchers, mocks or stubs. It is tightly integrated with XCTest and offers similar configuration capabilities as Cedar. 

As mentioned before Cedar, Kiwi and Specta offer similar syntax. I would not say that there is a framework that is better than all the others: they all have their small pros and cons. Choosing a BDD framework to work with mosty comes down to personall preference. 

It is also worth mentioning that there are already two BDD frameworks that are dedicated to Swift:

* [Sleipnir](https://github.com/railsware/Sleipnir)
* [Quick](https://github.com/Quick/Quick)

## Testing behaviors

Behavior testing means that you are testing, well, behaviors. By that I mean you should only care about interface defined by your object: what methods and dependencies it has. 

These methods, these dependencies define *contract* of your object. They define how it should interact with the rest of your application and what capabilities and functionalities it has. And that is what you should be aiming at: testing that interactions only, leaving other details apart. 

This brings quite a few benefits to your test suite. First of all you can cover more functionality with less tests, which means less work for you, less maintenance and faster execution of your test suite. 

Second of all by testing interface of an object your tests become immune to change. They won't easily break when you exchange implementation of an object. This a desired behavior as it will save you time when you perform a bigger refactor.

Last, but not least, behavior tests force you to think *how* your object should behave before you actually write it, resulting in a more thinked-through architecture of your app. Moreover by writing examples that define behavior of your object prior to actual implementation you be sure that, after all tests pass, your object works as expected. 

The key aspect of writing good behavioral tests is identifying dependencies (you can read more on this subject [here](link to Jons article)) and exposing them in your interface. 

Most of your tests will either assert whether a specific interaction happened, or whether a specific value was returned (or passed in to another object) based on your tested object state. Extracting dependencies will allow you to easilly mock values and states. Moreover it will greatly simplify asserting whether a specific action happend or a specific value was calculated.

Keep in mind that you shouldn't put *all* of your objects dependencies and properties in the interface (which, especially when you start testing, is really tempting). This will decrease readability and clarity of purpose of your object, whereas your interface should clearly state what it was designed for. 

Let's now take a look at a few examples of how can we test behaviors of components. 

#### Message Formatter

Let's start with a simple example. We'll build a component that is responsible for formatting a text message (think about a detailed description of an object that will fit somewhere in UI) based on a passed in object. 

	@interface EventDescriptionFormatter : NSObject
	@property(nonatomic, strong) NSDateFormatter *dateFormatter;
	
	- (NSString *)eventDescriptionFromEvent:(id <Event>)event;
	
	@end

This is how our interface looks like. The event protocol defines three basic properties of an event:

	@protocol Event <NSObject>
	
	@property(nonatomic, readonly) NSString *name;
	
	@property(nonatomic, readonly) NSDate *startDate;
	@property(nonatomic, readonly) NSDate *endDate;
	
	@end

Our goal is to test whether `EventDescriptionFormatter` returns a formatted description that looks like `My Event starts at Aug 21, 2014, 12:00 AM and ends at Aug 21, 2014, 1:00 AM.`. 

Please note that this (and all other examples in this article) use mocking frameworks. If you never used a mocking framework before you should consult this article.

We'll start by mocking our only dependency in the component, which is the date formatter. We'll use the created mock to return fixture strings for start and end dates. And finally we'll check whether the string returned from event formatter is constructed using the values that we have just mocked. 

        __block id mockDateFormatter;
        __block NSString *eventDescription;
        __block id mockEvent;

        beforeEach(^{
        	// Prepare mock date formatter
            mockDateFormatter = mock([NSDateFormatter class]);
            descriptionFormatter.dateFormatter = mockDateFormatter;

            NSDate *startDate = [NSDate mt_dateFromYear:2014 month:8 day:21];
            NSDate *endDate = [startDate mt_dateHoursAfter:1];

			// Pepare mock event
            mockEvent = mockProtocol(@protocol(Event));
            [given([mockEvent name]) willReturn:@"Fixture Name"];
            [given([mockEvent startDate]) willReturn:startDate];
            [given([mockEvent endDate]) willReturn:endDate];

            [given([mockDateFormatter stringFromDate:startDate]) willReturn:@"Fixture String 1"];
            [given([mockDateFormatter stringFromDate:endDate]) willReturn:@"Fixture String 2"];

            eventDescription = [descriptionFormatter eventDescriptionFromEvent:mockEvent];
        });

        it(@"should return formatted description", ^{
            expect(eventDescription).to.equal(@"Fixture Name starts at Fixture String 1 and ends at Fixture String 2.");
        });
        
Note that we have only tested whether our `EventDescriptionFormatter` uses its `NSDateFormatter` for formatting the dates. We haven't actually tested the format style. Thus, to have a fully tested component, we need to add two more tests that check format style:

    it(@"should have appropriate date style on date formatter", ^{
        expect(descriptionFormatter.dateFormatter.dateStyle).to.equal(NSDateFormatterMediumStyle);
    });

    it(@"should have appropriate time style on date formatter", ^{
        expect(descriptionFormatter.dateFormatter.timeStyle).to.equal(NSDateFormatterMediumStyle);
    });
    
Even though we have a fully tested component we wrote quite a few tests. And this is a really small component, isn't it? Let's try approaching this issue from a bit different angle.

The example above doesn't exactly test *behavior* of `EventDescriptionFormatter`. It mostly tests its internal implementation by mocking the `NSDateFormatter`. In fact, we don't actualy care whether there's a date formatter underneath at all. From interface persepctive we could've been formatting the date manually by using date components. All we care about at this point is whether we got our string right. And that is the behavior that we want to test.

We can easily achieve this by not mocking the `NSDateFormatter`. As said before, we don't even care whether its there so let's remove it from the interface. 

	@interface EventDescriptionFormatter : NSObject
	
	- (NSString *)eventDescriptionFromEvent:(id <Event>)event;
	
	@end
	
Next step is, of course, refactoring our tests. Now that we no longer need to know the internals of event formatter we can focus on actual behavior:

     describe(@"event description from event", ^{

        __block NSString *eventDescription;
        __block id mockEvent;

        beforeEach(^{
            NSDate *startDate = [NSDate mt_dateFromYear:2014 month:8 day:21];
            NSDate *endDate = [startDate mt_dateHoursAfter:1];

            mockEvent = mockProtocol(@protocol(Event));
            [given([mockEvent name]) willReturn:@"Fixture Name"];
            [given([mockEvent startDate]) willReturn:startDate];
            [given([mockEvent endDate]) willReturn:endDate];

            eventDescription = [descriptionFormatter eventDescriptionFromEvent:mockEvent];
        });

        it(@"should return formatted description", ^{
            expect(eventDescription).to.equal(@"Fixture Name starts at Aug 21, 2014, 12:00 AM and ends at Aug 21, 2014, 1:00 AM.");
        });
    });

Event though this is a rather trival example there is something universal in its message. By testing interface only we make sure that our tests aren't fragile to future changes. 

#### ????

### Testing view controllers

It seems that the most common attitude to testing view controllers among iOS developers is that people don't see value in it. Which I find odd as controllers often represent the core aspect of application. They are the place where all components are glued together. They are the place that connects user interface with application logic and model. Thus damaged caused by a involutnary change can be substantial. 

This is why I strongly believe that view controllers should be tested as well. However testing view controllers is not an easy task. The Upload Photo and Login View examples should help with understanding how BDD can be leveraged to simplify building view controllers tests.

#### Upload Photo View Controller

In this example we will build a simple photo uploader view controller with a Send button as `rightBarButtonItem`. After the button is pressed view controller will inform its photo uploader component that a photo should be uploaded. 

Simple, right? Let's start with interface of `PhotoUploaderViewController`:

	@interface PhotoUploadViewController : UIViewController
	@property(nonatomic, readonly) PhotoUploader *photoUploader;
	
	- (instancetype)initWithPhotoUploader:(PhotoUploader *)photoUploader;
	
	@end
	
There's not much happening here as we're only defining an external dependency on `PhotoUploader`. Our implementation is also pretty simple. For the sake of simplicity we won't actually grab a photo from anywhere, we'll just create an empty `UIImage`. 

	@implementation PhotoUploadViewController
	
	- (instancetype)initWithPhotoUploader:(PhotoUploader *)photoUploader {
	    self = [super init];
	    if (self) {
	        _photoUploader = photoUploader;
	
	        self.navigationItem.rightBarButtonItem = [[UIBarButtonItem alloc] initWithTitle:NSLocalizedString(@"Upload", nil) style:UIBarButtonItemStyleBordered target:self action:@selector(didTapUploadButton:)];
	    }
	
	    return self;
	}
	
	#pragma mark -
	
	- (void)didTapUploadButton:(UIBarButtonItem *)uploadButton {
	    void (^completion)(NSError *) = ^(NSError* error){};
	    [self.photoUploader uploadPhoto:[UIImage new] completion:completion];
	}
	
	@end

Let's see how we could test this component. First of all we'll need to check whether our bar button item is property set up by asserting that title, target and action have been properly initialized: 

    describe(@"right bar button item", ^{

        __block UIBarButtonItem *barButtonItem;

        beforeEach(^{
            barButtonItem = [[photoUploadViewController navigationItem] rightBarButtonItem];
        });

        it(@"should have a title", ^{
            expect(barButtonItem.title).to.equal(@"Upload");
        });

        it(@"should have a target", ^{
            expect(barButtonItem.target).to.equal(photoUploadViewController);
        });

        it(@"should have an action", ^{
            expect(barButtonItem.action).to.equal(@selector(didTapUploadButton:));
        });
    });
    
But this is only a half of what actually needs to be tested: we are now sure that appropriate method will be called when the button is pressed, but we're not sure whether appropriate action will be taken (in fact, we don't even know whether that method actually exists). So let's test that as well:

    describe(@"tapping right bar button item", ^{
        beforeEach(^{
            [photoUploadViewController didTapUploadButton:nil];
        });

        it(@"should tell the mock photo uploader to upload the photo", ^{
            [verify(mockPhotoUploader) uploadPhoto:instanceOf([UIImage class])
                                        completion:anything()];
        });
    });

Unfortunately for us the `didTapUploadButton:` is not visible in the interface. We can work around this issue by defining a category visible in our tests that exposes this method:

	@interface PhotoUploadViewController (Specs)
	- (void)didTapUploadButton:(UIBarButtonItem *)uploadButton;
	@end
	
At this point we can say that `PhotoUploadViewController` is fully tested. 

But what is wrong with the example above? The problem is that we are testing the internal implementation of `PhotoUploadViewController`. We shouldn't actually *care* what are the target/action values on the bar button item. We should only care about what happens when it is pressed. Everything else is an implementation detail which should be easily changed without breaking any tests.  

Let's go back to our `PhotoUploadViewController` and see how we could rewrite our tests to make sure we're not testing implementation, but just our interface. 

First of all, we don't need to know that `didTapUploadButton:` method exists at all. It is just an implementation detail. We care only for the behavior: when user taps Upload button the `UploadManager` should recieve a `uploadPhoto:` message. This is great as it means we don't really need our `Specs` category on `PhotoUploadViewController`. 

Second of all, we don't need to know what target/action is defined on our `rightBarButtonItem`. Our *only* concern is what happens when it is tapped. Let's simulate that action in tests. We can use a helper category on `UIBarButtonItem` to do this:

	@interface UIBarButtonItem (Specs)
	
	- (void)specsSimulateTap;
	
	@end
	
Its implementation is pretty simple as we're performing `action` on `target` of the `UIBarButtonItem`:

	@implementation UIBarButtonItem (Specs)
	
	- (void)specsSimulateTap {
	    [self.target performSelector:self.action withObject:self];
	}
	
	@end

Now that we have a helper method that simulates a tap we can simplify our tests to one top-level `describe` block:

    describe(@"right bar button item", ^{

        __block UIBarButtonItem *barButtonItem;

        beforeEach(^{
            barButtonItem = [[photoUploadViewController navigationItem] rightBarButtonItem];
        });

        it(@"should have a title", ^{
            expect(barButtonItem.title).to.equal(@"Upload");
        });

        describe(@"when it is tapped", ^{
            beforeEach(^{
                [barButtonItem specsSimulateTap];
            });

            it(@"should tell the mock photo uploader to upload the photo", ^{
                [verify(mockPhotoUploader) uploadPhoto:instanceOf([UIImage class])
                                            completion:anything()];
            });
        });
    });

Note that we have managed to remove two tests and we still have a fully tested component. Moreover out test suite is less prone to breaking as we no longer rely on existance of `didTapUploadButton:` method. Last but not least we have focused more on the behavioral aspect of our controller, rather than its internal implementation.

#### Login View Controller

In this example we will build a simple app that requires users to enter username and password in order to sign in to an abstract service.  

We will start out by building a `LoginViewController` with two text fields and a sign in button. We want to keep our controller as small as possible, so we will abstract a class responsible for signing in to a separate component called `SignInManager`. 
	
Our requirements are as follows: when user presses out login button, and username and password are present, our view controller will tell its sign in manager to perform sign in with password and username. If there is no username or password (or both are gone) the app will show an error label above text fields. 

First thing that we will want to test is the view part. 

	@interface SignInViewController : UIViewController
	
	@property(nonatomic, readwrite) IBOutlet UIButton *signInButton;
	
	@property(nonatomic, readwrite) IBOutlet UITextField *usernameTextField;
	@property(nonatomic, readwrite) IBOutlet UITextField *passwordTextField;
	
	@property(nonatomic, readwrite) IBOutlet UILabel *fillInBothFieldsLabel;
	
	@property(nonatomic, readonly) SignInManager *signInManager;
	
	- (instancetype)initWithSignInManager:(SignInManager *)signInManager;
	
	- (IBAction)didTapSignInButton:(UIButton *)signInButton;
	
	@end


In order to test our controller we will need to somehow expose existance of our 

First we will check some basic information about our text fields:

        beforeEach(^{
            // Force view load from xib
            [loginViewController view];
        });

        it(@"should have a placeholder on user name text field", ^{
            expect(loginViewController.usernameTextField.placeholder).to.equal(@"Username");
        });

        it(@"should have a placeholder on user name text field", ^{
             expect(loginViewController.passwordTextField.placeholder).to.equal(@"Password");
        });
        
Next we will check whether sign in button is correctly configured and has it actions wired:

        describe(@"sign in button", ^{

            __block UIButton *button;

            beforeEach(^{
                button = loginViewController.signInButton;
            });

            it(@"should have a title", ^{
                expect(button.currentTitle).to.equal(@"Sign In");
            });

            it(@"should login view controller as only target", ^{
                expect(button.allTargets).to.equal([NSSet setWithObject:loginViewController]);
            });

            it(@"should have the sign in action as action for login view controller target", ^{
                NSString *selectorString = NSStringFromSelector(@selector(didTapSignInButton:));
                expect([button actionsForTarget:loginViewController forControlEvent:UIControlEventTouchUpInside]).to.equal(@[selectorString]);
            });
        });
        
And last, but not least, we will check how our controller behaves when the button is tapped:

	describe(@"tapping the logging button", ^{
         context(@"when login and password are present", ^{

             beforeEach(^{
                 loginViewController.usernameTextField.text = @"Fixture Username";
                 loginViewController.passwordTextField.text = @"Fixture Password";

                 // Make sure state is different than the one expected
                 loginViewController.fillInBothFieldsLabel.alpha = 1.0f;

                 [loginViewController didTapSignInButton:nil];
             });

             it(@"should tell the sign in manager to sign in with given username and password", ^{
                 [verify(mockSignInManager) signInWithUsername:@"Fixture Username" password:@"Fixture Password"];
             });
         });

         context(@"when login or password are not present", ^{
             beforeEach(^{
                 loginViewController.usernameTextField.text = @"Fixture Username";
                 loginViewController.passwordTextField.text = nil;

                 [loginViewController didTapSignInButton:nil];
             });

             it(@"should tell the sign in manager to sign in with given username and password", ^{
                 [verifyCount(mockSignInManager, never()) signInWithUsername:anything() password:anything()];
             });
         });

         context(@"when neither login or password are present", ^{
             beforeEach(^{
                 loginViewController.usernameTextField.text = nil;
                 loginViewController.passwordTextField.text = nil;

                 [loginViewController didTapSignInButton:nil];
             });

             it(@"should tell the sign in manager to sign in with given username and password", ^{
                 [verifyCount(mockSignInManager, never()) signInWithUsername:anything() password:anything()];
             });
         });
     });

Code presented in example above has quite a few issues. First of all we've exposed a lot of internal implementation of `SignInViewController`, including buttons, textfields and methods. The truth is that we didn't really need to do all of this. 

Let us see how we can refactor these tests to make sure we are not touching internal implementation. We will start by removing the need to actually know what target and method are hooked to sign in button:

	@interface UIButton (Specs)
	
	- (void)specsSimulateTap;
	
	@end
	
	@implementation UIButton (Specs)
	
	- (void)specsSimulateTap {
	    [self sendActionsForControlEvents:UIControlEventTouchUpInside];
	}
	
	@end

Now we can just call this method on our button and assert whether sign in manager received appropriate message. But we can still improve how this test is written. 

Let us assume that we do not want to know who has the sign in button. Perhaps it is a direct subview of the view controllers view. Or perhaps we encapsulated it within a separate view that has its own delegate. We shouldn't actually care where it is, we should only care whether it is somewhere within our view controllers view and what happens when it is tapped. We can use a helper method to grab the sign in button, no matter where it is:

	@interface UIView (Specs)
	
	- (UIButton *)specsFindButtonWithTitle:(NSString *)title;
	
	@end
	
Our method will travers subviews of the view and return first button that has a title that matches passed in title. We can write similar methods for text fields or labels:

	@interface UIView (Specs)
	
	- (UITextField *)specsFindTextFieldWithPlaceholder:(NSString *)placeholder;
	- (UILabel *)specsFindLabelWithText:(NSString *)text;
	
	@end
	
Let us see how our tests look like now:

	describe(@"view", ^{

        __block UIView *view;
        
        beforeEach(^{
            view = [loginViewController view];
        });

        describe(@"login button", ^{

            __block UITextField *usernameTextField;
            __block UITextField *passwordTextField;
            __block UIButton *signInButton;

            beforeEach(^{
                signInButton = [view specsFindButtonWithTitle:@"Sign In"];
                usernameTextField = [view specsFindTextFieldWithPlaceholder:@"Username"];
                passwordTextField = [view specsFindTextFieldWithPlaceholder:@"Password"];
            });

            context(@"when login and password are present", ^{
                beforeEach(^{
                    usernameTextField.text = @"Fixture Username";
                    passwordTextField.text = @"Fixture Password";

                    [signInButton specsSimulateTap];
                });

                it(@"should tell the sign in manager to sign in with given username and password", ^{
                    [verify(mockSignInManager) signInWithUsername:@"Fixture Username" password:@"Fixture Password"];
                });
            });

            context(@"when login or password are not present", ^{
                beforeEach(^{
                    usernameTextField.text = @"Fixture Username";
                    passwordTextField.text = nil;

                    [signInButton specsSimulateTap];
                });

                it(@"should tell the sign in manager to sign in with given username and password", ^{
                    [verifyCount(mockSignInManager, never()) signInWithUsername:anything() password:anything()];
                });
            });

            context(@"when neither login or password are present", ^{
                beforeEach(^{
                    usernameTextField.text = nil;
                    passwordTextField.text = nil;

                    [signInButton specsSimulateTap];
                });

                it(@"should tell the sign in manager to sign in with given username and password", ^{
                    [verifyCount(mockSignInManager, never()) signInWithUsername:anything() password:anything()];
                });
            });
        });
    });
    
Looks much simpler, doesn't it? Note that by looking for a button with 'Sign In' as title we also tested whether such button exists at all. Moreover, by simulating a tap we tested whether the action is correctly hooked up. And in the end by asserting that our `SignInManager` should be called we tested whether that part is correctly implemented. All of this using three simple tests. 

What is also great is that we no longer need to expose any of those properties. As a matter of fact our interface could be as simple as this:

	@interface SignInViewController : UIViewController
	
	@property(nonatomic, readonly) SignInManager *signInManager;
	
	- (instancetype)initWithSignInManager:(SignInManager *)signInManager;
	
	@end

## Conclusion

Testing behaviors is not as hard as it might initially looked like. All you need to do is change your mindset a bit - think more of how an object should behave (and how its interface should look like) and less how it should be implemented. That way you will end up with more robust codebase as well as great test suite. 

