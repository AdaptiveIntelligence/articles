---
layout: post
title:  "BDD"
category: "1"
date: "2013-07-11 08:00:00"
author: "<a href=\"https://paweldudek.github.io\">Pawel Dudek</a>"
tags: article
---

We all know that writing tests is a great thing.[link to Luis Solano article]. There've been numerous articles written on why TDD is a great way for us programmers to write apps. But there's on

TDD stands for Test Driven Development. But what does it exaclty mean? Most people think it's just writing a test first. But really, it's not. If the only thing that you're doing with TDD is writing a test first then you're doing it wrong. 

TDD stands for Test *Driven* Development. It means that the tests are driving what you are writing and that they're here to guide you through that process. They're here to advise on what is probably a bad direction with the code and what's good. 

Remember that by writing a test first you're not only becoming the creator of an interface. You are also becoming the *first consumer* of it. And by doing that you get this unique chance to feel how the interface can be consumed. You then can make a sane decision whether that particular API is hard to use. 

Moreover if it is hard to <missing stuff> clarify requirements

Where does BDD fit into all of this? How does it differ from TDD?

http://blog.mattwynne.net/2012/11/20/tdd-vs-bdd/

## BDD Frameworks

BDD frameworks

Most of BDD frameworks inherit their syntax from RSpec[^1], a Ruby BDD framework. 

	SpecBegin(MyAwesomeViewController)
		describe(@"MyAwesomeViewController", ^{
			it(@"should ", ^{
			});
		});
	SpecEnd
	
`SpecBegin` is a simple macro that defines a class called `MyAwesomeViewControllerSpec`. `SpecEnd` closes that definion. 

- RSpec syntax: `it`,`describe`,`context`
- Compare Specta, Kiwi, Cedar 

## Testing behaviors

Before we dive into what is a behavior let's answer a bit more fundamental question - 

Let's take this one level deeper - an app is a set of objects, created by programmer, with a specific set of behaviors that are defined by their interface. 

So, in the end, your app is just a set of objects that have an interface. 

* What is a behavior?
	- Contract with other objects in the app. 
	- Behavior defined by contract and expected by other users. (programmers/objects)

### Testing contracts

Why

By testing internal implementation of an object your tests become fragile. They can easily break when you exchange the implementation of o

One of the traits of a good test suite is that it tests the interface, not the implementation. But why is this such a desired feature? 

When I first read this 

	- Why is it better to test contracts rather than implementation?

You can check out good and bad testing practices in this article. 

#### Message Formatter

Let's start with a simple example. We'll build a component that is responsible for formatting a text message (think about a detailed description of an object that will fit somewhere in UI) based on a passed in object. 

	@interface EventDescriptionFormatter : NSObject
	@property(nonatomic, strong) NSDateFormatter *dateFormatter;
	
	- (NSString *)eventDescriptionFromEvent:(id <Event>)event;
	
	@end

This is how our interface looks like. The event protocol defines three basic properties of an event:

	@protocol Event <NSObject>
	
	@property(nonatomic, readonly) NSString *name;
	
	@property(nonatomic, readonly) NSDate *startDate;
	@property(nonatomic, readonly) NSDate *endDate;
	
	@end

Our goal is to test whether `EventDescriptionFormatter` returns a formatted description that looks like `My Event starts at Aug 21, 2014, 12:00 AM and ends at Aug 21, 2014, 1:00 AM.`. 

We'll start by mocking our only dependency in the component, which is the date formatter. We'll use the created mock to return fixture strings for start and end dates. And finally we'll check whether the string returned from event formatter is constructed using the values that we have just mocked. 

        __block id mockDateFormatter;
        __block NSString *eventDescription;
        __block id mockEvent;

        beforeEach(^{
        	// Prepare mock date formatter
            mockDateFormatter = mock([NSDateFormatter class]);
            descriptionFormatter.dateFormatter = mockDateFormatter;

            NSDate *startDate = [NSDate mt_dateFromYear:2014 month:8 day:21];
            NSDate *endDate = [startDate mt_dateHoursAfter:1];

			// Pepare mock event
            mockEvent = mockProtocol(@protocol(Event));
            [given([mockEvent name]) willReturn:@"Fixture Name"];
            [given([mockEvent startDate]) willReturn:startDate];
            [given([mockEvent endDate]) willReturn:endDate];

            [given([mockDateFormatter stringFromDate:startDate]) willReturn:@"Fixture String 1"];
            [given([mockDateFormatter stringFromDate:endDate]) willReturn:@"Fixture String 2"];

            eventDescription = [descriptionFormatter eventDescriptionFromEvent:mockEvent];
        });

        it(@"should return formatted description", ^{
            expect(eventDescription).to.equal(@"Fixture Name starts at Fixture String 1 and ends at Fixture String 2.");
        });
        
Note that we have only tested whether our `EventDescriptionFormatter` uses its `NSDateFormatter` for formatting the dates. We haven't actually tested the format style. Thus, to have a fully tested component, we need to add two more tests that check format style:

    it(@"should have appropriate date style on date formatter", ^{
        expect(descriptionFormatter.dateFormatter.dateStyle).to.equal(NSDateFormatterMediumStyle);
    });

    it(@"should have appropriate time style on date formatter", ^{
        expect(descriptionFormatter.dateFormatter.timeStyle).to.equal(NSDateFormatterMediumStyle);
    });
    
Even though we have a fully tested component we wrote quite a few tests. And this is a really small component, isn't it? Let's try approaching this issue from a bit different angle.

The example above doesn't exactly test *behavior* of `EventDescriptionFormatter`. It mostly tests its internal implementation by mocking the `NSDateFormatter`. In fact, we don't actualy care whether there's a date formatter underneath at all. From interface persepctive we could've been formatting the date manually by using date components. All we care about at this point is whether we got our string right. And that is the behavior that we want to test.

We can easily achieve this by not mocking the `NSDateFormatter`. As said before, we don't even care whether its there so let's remove it from the interface. 

	@interface EventDescriptionFormatter : NSObject
	
	- (NSString *)eventDescriptionFromEvent:(id <Event>)event;
	
	@end
	
Next step is, of course, refactoring our tests. Now that we no longer need to know the internals of event formatter we can focus on actual behavior:

     describe(@"event description from event", ^{

        __block NSString *eventDescription;
        __block id mockEvent;

        beforeEach(^{
            NSDate *startDate = [NSDate mt_dateFromYear:2014 month:8 day:21];
            NSDate *endDate = [startDate mt_dateHoursAfter:1];

            mockEvent = mockProtocol(@protocol(Event));
            [given([mockEvent name]) willReturn:@"Fixture Name"];
            [given([mockEvent startDate]) willReturn:startDate];
            [given([mockEvent endDate]) willReturn:endDate];

            eventDescription = [descriptionFormatter eventDescriptionFromEvent:mockEvent];
        });

        it(@"should return formatted description", ^{
            expect(eventDescription).to.equal(@"Fixture Name starts at Aug 21, 2014, 12:00 AM and ends at Aug 21, 2014, 1:00 AM.");
        });
    });

Event though this is a rather trival example there is something universal in its message. By testing interface only we make sure that our tests aren't fragile to future changes. 

Imagine that at some point Apple releases a framework that can greatly simplify your components internal implementation. If you have your tests test the implementation itself you will also have to refactor them. Which means wasted time and, possibly, more bugs as you won't have your tests in place to make sure the contract defined by interface has not changed. 

### Testing view controllers & views

- Why testing view controllers is also important?
- How can we test behavior of view controllers?

#### Bar button item example

In this example we'll build a simple photo uploader view controller with a Send button as `rightBarButtonItem`. After the button is pressed view controller will inform its photo uploader component that a photo should be uploaded. 

Simple, right? Let's start with interface of `PhotoUploaderViewController`:

	@interface PhotoUploadViewController : UIViewController
	@property(nonatomic, readonly) PhotoUploader *photoUploader;
	
	- (instancetype)initWithPhotoUploader:(PhotoUploader *)photoUploader;
	
	@end
	
There's not much information here as we're only defining an external dependency on `PhotoUploader`. Our implementation is also pretty simple. For the sake of simplicity we won't actually grab a photo from anywhere, we'll just create an empty `UIImage`. 

	@implementation PhotoUploadViewController
	
	- (instancetype)initWithPhotoUploader:(PhotoUploader *)photoUploader {
	    self = [super init];
	    if (self) {
	        _photoUploader = photoUploader;
	
	        self.navigationItem.rightBarButtonItem = [[UIBarButtonItem alloc] initWithTitle:NSLocalizedString(@"Upload", nil) style:UIBarButtonItemStyleBordered target:self action:@selector(didTapUploadButton:)];
	    }
	
	    return self;
	}
	
	#pragma mark -
	
	- (void)didTapUploadButton:(UIBarButtonItem *)uploadButton {
	    void (^completion)(NSError *) = ^(NSError* error){};
	    [self.photoUploader uploadPhoto:[UIImage new] completion:completion];
	}
	
	@end

Let's see how we could test this component. First of all we'll need to check whether our bar button item is property set up by asserting that title, target and action have been properly initialized: 

    describe(@"right bar button item", ^{

        __block UIBarButtonItem *barButtonItem;

        beforeEach(^{
            barButtonItem = [[photoUploadViewController navigationItem] rightBarButtonItem];
        });

        it(@"should have a title", ^{
            expect(barButtonItem.title).to.equal(@"Upload");
        });

        it(@"should have a target", ^{
            expect(barButtonItem.target).to.equal(photoUploadViewController);
        });

        it(@"should have an action", ^{
            expect(barButtonItem.action).to.equal(@selector(didTapUploadButton:));
        });
    });
    
But this is only a half of what actually needs to be test: we are now sure that appropriate method will be called when the button is pressed, but we're not sure whether appropriate action will be taken (in fact, we don't even know whether that method actually exists). So let's test that as well:

    describe(@"tapping right bar button item", ^{
        beforeEach(^{
            [photoUploadViewController didTapUploadButton:nil];
        });

        it(@"should tell the mock photo uploader to upload the photo", ^{
            [verify(mockPhotoUploader) uploadPhoto:instanceOf([UIImage class])
                                        completion:anything()];
        });
    });

Unfortunately for us the `didTapUploadButton:` is not visible in the interface. We can work around this issue by defining a category visible in our tests that exposes this method:

	@interface PhotoUploadViewController (Specs)
	- (void)didTapUploadButton:(UIBarButtonItem *)uploadButton;
	@end

So what's wrong with the example above? We are testing the internal implementation of `PhotoUploadViewController`. We shouldn't actually *care* what are the target/action values on the bar button item. We should only care about what happens when it is pressed. Everything else is an implementation detail which should be easily changed without breaking any tests.  

Let's go back to our `PhotoUploadViewController` and see how we could rewrite our tests to make sure we're not testing implementation, but just our interface. 

First of all, we don't need to know that `didTapUploadButton:` method exists at all. It is just an implementation detail. We care only for the behavior: when user taps Upload button the `UploadManager` should recieve a `uploadPhoto:` message. This is great as it means we don't really need our `Specs` category on `PhotoUploadViewController`. 

Second of all, we don't need to know what target/action is defined on our `rightBarButtonItem`. Our *only* concern is what happens when it is tapped. Let's simulate that action in tests. We can use a helper category on `UIBarButtonItem` to do this:

	@interface UIBarButtonItem (Specs)
	
	- (void)specsSimulateTap;
	
	@end
	
Its implementation is pretty simple as we're performing `action` on `target` of the `UIBarButtonItem`:

	@implementation UIBarButtonItem (Specs)
	
	- (void)specsSimulateTap {
	    [self.target performSelector:self.action withObject:self];
	}
	
	@end

Now that we have a helper method that simulates a tap we can simplify our tests to one top-level `describe` block:

    describe(@"right bar button item", ^{

        __block UIBarButtonItem *barButtonItem;

        beforeEach(^{
            barButtonItem = [[photoUploadViewController navigationItem] rightBarButtonItem];
        });

        it(@"should have a title", ^{
            expect(barButtonItem.title).to.equal(@"Upload");
        });

        describe(@"when it is tapped", ^{
            beforeEach(^{
                [barButtonItem specsSimulateTap];
            });

            it(@"should tell the mock photo uploader to upload the photo", ^{
                [verify(mockPhotoUploader) uploadPhoto:instanceOf([UIImage class])
                                            completion:anything()];
            });
        });
    });



#### Login button example

Let's see how can we test behavior of a view controller. In order to do that we'll build a simple app that requires users to enter username and password in order to sign in to an abstract service.  

We'll start out by building a `LoginViewController` with two text fields and a sign in button. We want to keep our controller as small as possible, so we will abstract a class responsible for signing in to a separate component called `SignInManager`. 
	
When user presses out login button, and username and password are present, our view controller will tell its sign in manager to perform sign in with password and username. If there is no username or password (or both are gone) the app will show an error label above text fields. 

Please note that this (and all other examples in this article) use mocking frameworks. If you never used a mocking framework before you should consult this article.

First thing that we'll want to test is the view part. 

	@interface SignInViewController : UIViewController
	
	@property(nonatomic, strong) IBOutlet UIButton *signInButton;
	
	@property(nonatomic, strong) IBOutlet UITextField *usernameTextField;
	@property(nonatomic, strong) IBOutlet UITextField *passwordTextField;
	
	@property(nonatomic, readonly) SignInManager *signInManager;
	
	- (instancetype)initWithSignInManager:(SignInManager *)signInManager;
	
	- (IBAction)didTapSignInButton:(UIButton *)signInButton;
	
	@end

In order to test our controller we will need to somehow expose existance of our 

Code presented in example above has quite a few issues. First of all we've exposed a lot of internal implementation of `SignInViewController` (buttons, actions) just to be able to test it. 

## Conclusion


	
## Tightening your cycles

This is not exactly the core part of this article, but I really wanted to share how can you improve 

### Running specs from command line

as it doesn't distract you and, at the 



### Prettifying output

Unfortunately output from `xcodebuild test` is not exactly readable. Imagine what happens when your app reaches 2000 (or more) tests - finding which test failed would become quite a challange and, as said before, we want to run our tests as often as possible and as quickly as possible. 

This is where xcpretty comes in. 
https://github.com/supermarin/xcpretty

Xcpretty is a really simple tool - the only thing it actually does is parsing the output Xcode throws out when performing `xcodebuild test`. 

## The action block

- Problem: RSpec has issues with separating arrange and act parts of test. Assert clearly separated.
- Solution: the action block!
- Example usage (simplified version with action from one of previous examples)

## Thank you's

- Robert Wijas for idea with traversing hierarchy & predicates
- Lukasz Warchol for action block


