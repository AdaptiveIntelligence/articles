---
layout: post
title: "Introduction to MVVM"
date: 2013-12-04 11:36
comments: true
author: Ash Furrow
categories: iOS, OS X
---

I got my first real iOS job at 500px in 2011. I had been doing iOS contracting for a few years in college, but this was my first, real iOS gig. I was hired as the sole iOS developer to make the beautifully designed iPad app. In only seven weeks, we shipped a 1.0 and continued to iterate, adding more features and, intrinsically, more complexity to the codebase.

It felt at times like I didn't know what I was doing. I knew my design patterns – like any good coder – but I was way too close to the product I was making to objectively measure the efficacy of my architectural decisions. It took bringing another developer on board the team for me to realize that we were in trouble. 

Ever heard of MVC? Massive View Controller, some call it. That's certainly how it felt at the time. I won't go into the embarrassing details, but it suffices to say that if I had to do it all over again, I would make different decisions. 

One of the key architectural changes I would make, and have made in apps I've developed since then, would be to use an alternative to Model-View-Controller called Model-View-ViewModel. 

So what is MVVM, exactly? Instead of focusing on the historical context of where MVVM came from, let's take a look at what a typical iOS app looks like and derive MVVM from there.

![Typical Model-View-Controller setup](http://cloud.ashfurrow.com/image/2M3J3A3B191M/mvvm.png)

Here we see a typical MVC setup. Models represent data, views represent user interfaces, and view controllers mediate the interactions between the two of them. Cool. 

Consider for a moment that, although views and view controllers are technically distinct components, they almost always go hand-in-hand together, paired. When is the last time that a view could be paired with different view controllers? Or vice versa? So why not formalize their connection?

![Intermediate](http://cloud.ashfurrow.com/image/1F0H1P07312L/intermediate.png)

This more accurately describes the MVC code that you're probably already writing. But it doesn't do much to address the massive view controllers that tend to grow in iOS apps. In typical MVC applications, a *lot* of logic gets placed in the view controller. Some of it belongs in the view controller, sure, but a lot of it is what's called "presentation logic" in MVVM terms. Things like transforming values from the model into something the view can present, like taking an `NSDate` and turning it into a formatted `NSString`.

We're missing something from our diagram. Something where we can place all of that presentation logic. We're going to call this the "view model" – it will sit between the view/controller and the model. 

![Model-View-ViewModel](http://cloud.ashfurrow.com/image/2v27431h3O0S/mvvm.png)

Looking better! This diagram accurately describes what MVVM is: an augmented version of MVC where we formally connect the view and controller, and move presentation logic out of the controller and into a new object: the view model. MVVM sounds complicated, but it's essentially a dressed-up version of the MVC architecture that you're already familiar with. 

So now that we know *what* MVVM is, *why* would you want to use it? The motivation behind MVVM on iOS, for me, anyway, is that it reduces the complexity of your view controllers and makes your presentation logic easier to test. We'll see how it accomplishes these goals with some examples. 

There are three really important points I want you to take away from this article:

- MVVM is compatible with your existing MVC architecture.
- MVVM works best with a binding mechanism.
- MVVM makes your apps more testable.
